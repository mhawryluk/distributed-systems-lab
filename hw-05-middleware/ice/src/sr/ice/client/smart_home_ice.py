# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.7
#
# <auto-generated>
#
# Generated from file `smart_home.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module SmartHome
_M_SmartHome = Ice.openModule('SmartHome')
__name__ = 'SmartHome'

_M_SmartHome._t_Device = IcePy.defineValue('::SmartHome::Device', Ice.Value, -1, (), False, True, None, ())

if 'DevicePrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.DevicePrx = Ice.createTempClass()
    class DevicePrx(Ice.ObjectPrx):

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.DevicePrx.ice_checkedCast(proxy, '::SmartHome::Device', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.DevicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Device'
    _M_SmartHome._t_DevicePrx = IcePy.defineProxy('::SmartHome::Device', DevicePrx)

    _M_SmartHome.DevicePrx = DevicePrx
    del DevicePrx

    _M_SmartHome.Device = Ice.createTempClass()
    class Device(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Device')

        def ice_id(self, current=None):
            return '::SmartHome::Device'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Device'

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_DeviceDisp)

        __repr__ = __str__

    _M_SmartHome._t_DeviceDisp = IcePy.defineClass('::SmartHome::Device', Device, (), None, ())
    Device._ice_type = _M_SmartHome._t_DeviceDisp

    _M_SmartHome.Device = Device
    del Device

if 'RadioStation' not in _M_SmartHome.__dict__:
    _M_SmartHome.RadioStation = Ice.createTempClass()
    class RadioStation(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    RadioStation.POP = RadioStation("POP", 0)
    RadioStation.ROCK = RadioStation("ROCK", 1)
    RadioStation.LATIN = RadioStation("LATIN", 2)
    RadioStation._enumerators = { 0:RadioStation.POP, 1:RadioStation.ROCK, 2:RadioStation.LATIN }

    _M_SmartHome._t_RadioStation = IcePy.defineEnum('::SmartHome::RadioStation', RadioStation, (), RadioStation._enumerators)

    _M_SmartHome.RadioStation = RadioStation
    del RadioStation

_M_SmartHome._t_SpeakerI = IcePy.defineValue('::SmartHome::SpeakerI', Ice.Value, -1, (), False, True, None, ())

if 'SpeakerIPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.SpeakerIPrx = Ice.createTempClass()
    class SpeakerIPrx(_M_SmartHome.DevicePrx):

        def getVolume(self, context=None):
            return _M_SmartHome.SpeakerI._op_getVolume.invoke(self, ((), context))

        def getVolumeAsync(self, context=None):
            return _M_SmartHome.SpeakerI._op_getVolume.invokeAsync(self, ((), context))

        def begin_getVolume(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.SpeakerI._op_getVolume.begin(self, ((), _response, _ex, _sent, context))

        def end_getVolume(self, _r):
            return _M_SmartHome.SpeakerI._op_getVolume.end(self, _r)

        def volumeChange(self, delta, context=None):
            return _M_SmartHome.SpeakerI._op_volumeChange.invoke(self, ((delta, ), context))

        def volumeChangeAsync(self, delta, context=None):
            return _M_SmartHome.SpeakerI._op_volumeChange.invokeAsync(self, ((delta, ), context))

        def begin_volumeChange(self, delta, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.SpeakerI._op_volumeChange.begin(self, ((delta, ), _response, _ex, _sent, context))

        def end_volumeChange(self, _r):
            return _M_SmartHome.SpeakerI._op_volumeChange.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.SpeakerIPrx.ice_checkedCast(proxy, '::SmartHome::SpeakerI', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.SpeakerIPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::SpeakerI'
    _M_SmartHome._t_SpeakerIPrx = IcePy.defineProxy('::SmartHome::SpeakerI', SpeakerIPrx)

    _M_SmartHome.SpeakerIPrx = SpeakerIPrx
    del SpeakerIPrx

    _M_SmartHome.SpeakerI = Ice.createTempClass()
    class SpeakerI(_M_SmartHome.Device):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Device', '::SmartHome::SpeakerI')

        def ice_id(self, current=None):
            return '::SmartHome::SpeakerI'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::SpeakerI'

        def getVolume(self, current=None):
            raise NotImplementedError("servant method 'getVolume' not implemented")

        def volumeChange(self, delta, current=None):
            raise NotImplementedError("servant method 'volumeChange' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_SpeakerIDisp)

        __repr__ = __str__

    _M_SmartHome._t_SpeakerIDisp = IcePy.defineClass('::SmartHome::SpeakerI', SpeakerI, (), None, (_M_SmartHome._t_DeviceDisp,))
    SpeakerI._ice_type = _M_SmartHome._t_SpeakerIDisp

    SpeakerI._op_getVolume = IcePy.Operation('getVolume', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_int, False, 0), ())
    SpeakerI._op_volumeChange = IcePy.Operation('volumeChange', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0),), (), None, ())

    _M_SmartHome.SpeakerI = SpeakerI
    del SpeakerI

_M_SmartHome._t_RadioSpeakerI = IcePy.defineValue('::SmartHome::RadioSpeakerI', Ice.Value, -1, (), False, True, None, ())

if 'RadioSpeakerIPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.RadioSpeakerIPrx = Ice.createTempClass()
    class RadioSpeakerIPrx(_M_SmartHome.SpeakerIPrx):

        def setStation(self, station, context=None):
            return _M_SmartHome.RadioSpeakerI._op_setStation.invoke(self, ((station, ), context))

        def setStationAsync(self, station, context=None):
            return _M_SmartHome.RadioSpeakerI._op_setStation.invokeAsync(self, ((station, ), context))

        def begin_setStation(self, station, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.RadioSpeakerI._op_setStation.begin(self, ((station, ), _response, _ex, _sent, context))

        def end_setStation(self, _r):
            return _M_SmartHome.RadioSpeakerI._op_setStation.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.RadioSpeakerIPrx.ice_checkedCast(proxy, '::SmartHome::RadioSpeakerI', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.RadioSpeakerIPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::RadioSpeakerI'
    _M_SmartHome._t_RadioSpeakerIPrx = IcePy.defineProxy('::SmartHome::RadioSpeakerI', RadioSpeakerIPrx)

    _M_SmartHome.RadioSpeakerIPrx = RadioSpeakerIPrx
    del RadioSpeakerIPrx

    _M_SmartHome.RadioSpeakerI = Ice.createTempClass()
    class RadioSpeakerI(_M_SmartHome.SpeakerI):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Device', '::SmartHome::RadioSpeakerI', '::SmartHome::SpeakerI')

        def ice_id(self, current=None):
            return '::SmartHome::RadioSpeakerI'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::RadioSpeakerI'

        def setStation(self, station, current=None):
            raise NotImplementedError("servant method 'setStation' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_RadioSpeakerIDisp)

        __repr__ = __str__

    _M_SmartHome._t_RadioSpeakerIDisp = IcePy.defineClass('::SmartHome::RadioSpeakerI', RadioSpeakerI, (), None, (_M_SmartHome._t_SpeakerIDisp,))
    RadioSpeakerI._ice_type = _M_SmartHome._t_RadioSpeakerIDisp

    RadioSpeakerI._op_setStation = IcePy.Operation('setStation', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_RadioStation, False, 0),), (), None, ())

    _M_SmartHome.RadioSpeakerI = RadioSpeakerI
    del RadioSpeakerI

if 'Song' not in _M_SmartHome.__dict__:
    _M_SmartHome.Song = Ice.createTempClass()
    class Song(object):
        def __init__(self, artist='', title=''):
            self.artist = artist
            self.title = title

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.artist)
            _h = 5 * _h + Ice.getHash(self.title)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHome.Song):
                return NotImplemented
            else:
                if self.artist is None or other.artist is None:
                    if self.artist != other.artist:
                        return (-1 if self.artist is None else 1)
                else:
                    if self.artist < other.artist:
                        return -1
                    elif self.artist > other.artist:
                        return 1
                if self.title is None or other.title is None:
                    if self.title != other.title:
                        return (-1 if self.title is None else 1)
                else:
                    if self.title < other.title:
                        return -1
                    elif self.title > other.title:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_Song)

        __repr__ = __str__

    _M_SmartHome._t_Song = IcePy.defineStruct('::SmartHome::Song', Song, (), (
        ('artist', (), IcePy._t_string),
        ('title', (), IcePy._t_string)
    ))

    _M_SmartHome.Song = Song
    del Song

_M_SmartHome._t_BTSpeakerI = IcePy.defineValue('::SmartHome::BTSpeakerI', Ice.Value, -1, (), False, True, None, ())

if 'BTSpeakerIPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.BTSpeakerIPrx = Ice.createTempClass()
    class BTSpeakerIPrx(_M_SmartHome.SpeakerIPrx):

        def setSong(self, song, context=None):
            return _M_SmartHome.BTSpeakerI._op_setSong.invoke(self, ((song, ), context))

        def setSongAsync(self, song, context=None):
            return _M_SmartHome.BTSpeakerI._op_setSong.invokeAsync(self, ((song, ), context))

        def begin_setSong(self, song, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.BTSpeakerI._op_setSong.begin(self, ((song, ), _response, _ex, _sent, context))

        def end_setSong(self, _r):
            return _M_SmartHome.BTSpeakerI._op_setSong.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.BTSpeakerIPrx.ice_checkedCast(proxy, '::SmartHome::BTSpeakerI', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.BTSpeakerIPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::BTSpeakerI'
    _M_SmartHome._t_BTSpeakerIPrx = IcePy.defineProxy('::SmartHome::BTSpeakerI', BTSpeakerIPrx)

    _M_SmartHome.BTSpeakerIPrx = BTSpeakerIPrx
    del BTSpeakerIPrx

    _M_SmartHome.BTSpeakerI = Ice.createTempClass()
    class BTSpeakerI(_M_SmartHome.SpeakerI):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::BTSpeakerI', '::SmartHome::Device', '::SmartHome::SpeakerI')

        def ice_id(self, current=None):
            return '::SmartHome::BTSpeakerI'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::BTSpeakerI'

        def setSong(self, song, current=None):
            raise NotImplementedError("servant method 'setSong' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_BTSpeakerIDisp)

        __repr__ = __str__

    _M_SmartHome._t_BTSpeakerIDisp = IcePy.defineClass('::SmartHome::BTSpeakerI', BTSpeakerI, (), None, (_M_SmartHome._t_SpeakerIDisp,))
    BTSpeakerI._ice_type = _M_SmartHome._t_BTSpeakerIDisp

    BTSpeakerI._op_setSong = IcePy.Operation('setSong', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_Song, False, 0),), (), None, ())

    _M_SmartHome.BTSpeakerI = BTSpeakerI
    del BTSpeakerI

if 'InvalidColorException' not in _M_SmartHome.__dict__:
    _M_SmartHome.InvalidColorException = Ice.createTempClass()
    class InvalidColorException(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::InvalidColorException'

    _M_SmartHome._t_InvalidColorException = IcePy.defineException('::SmartHome::InvalidColorException', InvalidColorException, (), False, None, ())
    InvalidColorException._ice_type = _M_SmartHome._t_InvalidColorException

    _M_SmartHome.InvalidColorException = InvalidColorException
    del InvalidColorException

if 'Color' not in _M_SmartHome.__dict__:
    _M_SmartHome.Color = Ice.createTempClass()
    class Color(object):
        def __init__(self, R=0, G=0, B=0):
            self.R = R
            self.G = G
            self.B = B

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.R)
            _h = 5 * _h + Ice.getHash(self.G)
            _h = 5 * _h + Ice.getHash(self.B)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHome.Color):
                return NotImplemented
            else:
                if self.R is None or other.R is None:
                    if self.R != other.R:
                        return (-1 if self.R is None else 1)
                else:
                    if self.R < other.R:
                        return -1
                    elif self.R > other.R:
                        return 1
                if self.G is None or other.G is None:
                    if self.G != other.G:
                        return (-1 if self.G is None else 1)
                else:
                    if self.G < other.G:
                        return -1
                    elif self.G > other.G:
                        return 1
                if self.B is None or other.B is None:
                    if self.B != other.B:
                        return (-1 if self.B is None else 1)
                else:
                    if self.B < other.B:
                        return -1
                    elif self.B > other.B:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_Color)

        __repr__ = __str__

    _M_SmartHome._t_Color = IcePy.defineStruct('::SmartHome::Color', Color, (), (
        ('R', (), IcePy._t_int),
        ('G', (), IcePy._t_int),
        ('B', (), IcePy._t_int)
    ))

    _M_SmartHome.Color = Color
    del Color

_M_SmartHome._t_LampI = IcePy.defineValue('::SmartHome::LampI', Ice.Value, -1, (), False, True, None, ())

if 'LampIPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.LampIPrx = Ice.createTempClass()
    class LampIPrx(_M_SmartHome.DevicePrx):

        def getColor(self, context=None):
            return _M_SmartHome.LampI._op_getColor.invoke(self, ((), context))

        def getColorAsync(self, context=None):
            return _M_SmartHome.LampI._op_getColor.invokeAsync(self, ((), context))

        def begin_getColor(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.LampI._op_getColor.begin(self, ((), _response, _ex, _sent, context))

        def end_getColor(self, _r):
            return _M_SmartHome.LampI._op_getColor.end(self, _r)

        def setColor(self, color, context=None):
            return _M_SmartHome.LampI._op_setColor.invoke(self, ((color, ), context))

        def setColorAsync(self, color, context=None):
            return _M_SmartHome.LampI._op_setColor.invokeAsync(self, ((color, ), context))

        def begin_setColor(self, color, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.LampI._op_setColor.begin(self, ((color, ), _response, _ex, _sent, context))

        def end_setColor(self, _r):
            return _M_SmartHome.LampI._op_setColor.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.LampIPrx.ice_checkedCast(proxy, '::SmartHome::LampI', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.LampIPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::LampI'
    _M_SmartHome._t_LampIPrx = IcePy.defineProxy('::SmartHome::LampI', LampIPrx)

    _M_SmartHome.LampIPrx = LampIPrx
    del LampIPrx

    _M_SmartHome.LampI = Ice.createTempClass()
    class LampI(_M_SmartHome.Device):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Device', '::SmartHome::LampI')

        def ice_id(self, current=None):
            return '::SmartHome::LampI'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::LampI'

        def getColor(self, current=None):
            raise NotImplementedError("servant method 'getColor' not implemented")

        def setColor(self, color, current=None):
            raise NotImplementedError("servant method 'setColor' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_LampIDisp)

        __repr__ = __str__

    _M_SmartHome._t_LampIDisp = IcePy.defineClass('::SmartHome::LampI', LampI, (), None, (_M_SmartHome._t_DeviceDisp,))
    LampI._ice_type = _M_SmartHome._t_LampIDisp

    LampI._op_getColor = IcePy.Operation('getColor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_SmartHome._t_Color, False, 0), ())
    LampI._op_setColor = IcePy.Operation('setColor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_Color, False, 0),), (), None, (_M_SmartHome._t_InvalidColorException,))

    _M_SmartHome.LampI = LampI
    del LampI

if '_t_Row' not in _M_SmartHome.__dict__:
    _M_SmartHome._t_Row = IcePy.defineSequence('::SmartHome::Row', (), IcePy._t_int)

if '_t_Image' not in _M_SmartHome.__dict__:
    _M_SmartHome._t_Image = IcePy.defineSequence('::SmartHome::Image', (), _M_SmartHome._t_Row)

if 'Resolution' not in _M_SmartHome.__dict__:
    _M_SmartHome.Resolution = Ice.createTempClass()
    class Resolution(object):
        def __init__(self, width=0, height=0):
            self.width = width
            self.height = height

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.width)
            _h = 5 * _h + Ice.getHash(self.height)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHome.Resolution):
                return NotImplemented
            else:
                if self.width is None or other.width is None:
                    if self.width != other.width:
                        return (-1 if self.width is None else 1)
                else:
                    if self.width < other.width:
                        return -1
                    elif self.width > other.width:
                        return 1
                if self.height is None or other.height is None:
                    if self.height != other.height:
                        return (-1 if self.height is None else 1)
                else:
                    if self.height < other.height:
                        return -1
                    elif self.height > other.height:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_Resolution)

        __repr__ = __str__

    _M_SmartHome._t_Resolution = IcePy.defineStruct('::SmartHome::Resolution', Resolution, (), (
        ('width', (), IcePy._t_int),
        ('height', (), IcePy._t_int)
    ))

    _M_SmartHome.Resolution = Resolution
    del Resolution

if 'InvalidResolutionException' not in _M_SmartHome.__dict__:
    _M_SmartHome.InvalidResolutionException = Ice.createTempClass()
    class InvalidResolutionException(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::InvalidResolutionException'

    _M_SmartHome._t_InvalidResolutionException = IcePy.defineException('::SmartHome::InvalidResolutionException', InvalidResolutionException, (), False, None, ())
    InvalidResolutionException._ice_type = _M_SmartHome._t_InvalidResolutionException

    _M_SmartHome.InvalidResolutionException = InvalidResolutionException
    del InvalidResolutionException

_M_SmartHome._t_CameraI = IcePy.defineValue('::SmartHome::CameraI', Ice.Value, -1, (), False, True, None, ())

if 'CameraIPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.CameraIPrx = Ice.createTempClass()
    class CameraIPrx(_M_SmartHome.DevicePrx):

        def getSnapshot(self, context=None):
            return _M_SmartHome.CameraI._op_getSnapshot.invoke(self, ((), context))

        def getSnapshotAsync(self, context=None):
            return _M_SmartHome.CameraI._op_getSnapshot.invokeAsync(self, ((), context))

        def begin_getSnapshot(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.CameraI._op_getSnapshot.begin(self, ((), _response, _ex, _sent, context))

        def end_getSnapshot(self, _r):
            return _M_SmartHome.CameraI._op_getSnapshot.end(self, _r)

        def setResolution(self, resolution, context=None):
            return _M_SmartHome.CameraI._op_setResolution.invoke(self, ((resolution, ), context))

        def setResolutionAsync(self, resolution, context=None):
            return _M_SmartHome.CameraI._op_setResolution.invokeAsync(self, ((resolution, ), context))

        def begin_setResolution(self, resolution, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.CameraI._op_setResolution.begin(self, ((resolution, ), _response, _ex, _sent, context))

        def end_setResolution(self, _r):
            return _M_SmartHome.CameraI._op_setResolution.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.CameraIPrx.ice_checkedCast(proxy, '::SmartHome::CameraI', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.CameraIPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::CameraI'
    _M_SmartHome._t_CameraIPrx = IcePy.defineProxy('::SmartHome::CameraI', CameraIPrx)

    _M_SmartHome.CameraIPrx = CameraIPrx
    del CameraIPrx

    _M_SmartHome.CameraI = Ice.createTempClass()
    class CameraI(_M_SmartHome.Device):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::CameraI', '::SmartHome::Device')

        def ice_id(self, current=None):
            return '::SmartHome::CameraI'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::CameraI'

        def getSnapshot(self, current=None):
            raise NotImplementedError("servant method 'getSnapshot' not implemented")

        def setResolution(self, resolution, current=None):
            raise NotImplementedError("servant method 'setResolution' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_CameraIDisp)

        __repr__ = __str__

    _M_SmartHome._t_CameraIDisp = IcePy.defineClass('::SmartHome::CameraI', CameraI, (), None, (_M_SmartHome._t_DeviceDisp,))
    CameraI._ice_type = _M_SmartHome._t_CameraIDisp

    CameraI._op_getSnapshot = IcePy.Operation('getSnapshot', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_SmartHome._t_Image, False, 0), ())
    CameraI._op_setResolution = IcePy.Operation('setResolution', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_Resolution, False, 0),), (), None, (_M_SmartHome._t_InvalidResolutionException,))

    _M_SmartHome.CameraI = CameraI
    del CameraI

# End of module SmartHome
